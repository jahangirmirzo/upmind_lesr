# ### Инкапсуляция в ООП (Объектно-Ориентированном Программировании)
#
# # **Инкапсуляция** — это принцип ООП, который заключается в скрытии внутренней реализации объекта от внешнего мира и предоставлении доступа к данным и методам объекта только через специально определённые интерфейсы.
# #
# # Этот принцип позволяет:
# #
# # 1. Защитить данные от прямого изменения, обеспечив контроль над тем, как данные используются.
# # 2. Сделать код более гибким и безопасным, так как изменения в одной части программы не повлияют на другие.
# # 3. Спрятать детали реализации объекта, оставив только необходимые интерфейсы для работы с ним.
# #
# # ### Пример 1: Простая инкапсуляция с использованием геттеров и сеттеров
# #
# # В этом примере создадим класс `Person`, который инкапсулирует возраст человека, чтобы нельзя было установить отрицательное значение для возраста.
#
#
# class Person:
#     def __init__(self, name, age):
#         self.name = name
#         self.__age = age  # Приватный атрибут
#
#     # Геттер для получения возраста
#     def get_age(self):
#         return self.__age
#
#     # Сеттер для установки возраста с проверкой
#     def set_age(self, age):
#         if age < 0:
#             print("Возраст не может быть отрицательным.")
#         else:
#             self.__age = age
#
# # Создание объекта
# person = Person("John", 25)
#
# # Доступ к возрасту через методы
# print(person.get_age())  # 25
#
# # Попытка установить неправильный возраст
# person.set_age(-5)  # Возраст не может быть отрицательным.
#
# # Установка корректного возраста
# person.set_age(30)
# print(person.get_age())  # 30
#
# # **Объяснение:**
# #
# # * Приватный атрибут `__age` не доступен напрямую извне класса.
# # * Используем методы `get_age` и `set_age` для безопасного получения и изменения значения возраста. Метод `set_age` проверяет корректность значения перед установкой.
#
# ### Пример 2: Инкапсуляция с приватным методом
#
# # В следующем примере создадим класс `BankAccount`, который инкапсулирует балансы и методы для их изменения.
#
# class BankAccount:
#     def __init__(self, owner, balance):
#         self.owner = owner
#         self.__balance = balance  # Приватный атрибут
#
#     # Геттер для получения баланса
#     def get_balance(self):
#         return self.__balance
#
#     # Приватный метод для обновления баланса
#     def __update_balance(self, amount):
#         self.__balance += amount
#
#     # Метод для пополнения счета
#     def deposit(self, amount):
#         if amount > 0:
#             self.__update_balance(amount)
#             print(f"Пополнено на {amount}")
#         else:
#             print("Сумма пополнения должна быть положительной.")
#
#     # Метод для снятия средств
#     def withdraw(self, amount):
#         if amount > 0 and amount <= self.__balance:
#             self.__update_balance(-amount)
#             print(f"Снято {amount}")
#         else:
#             print("Недостаточно средств или неверная сумма.")
#
# # Создание объекта
# account = BankAccount("Alice", 1000)
#
# # Пополнение счета
# account.deposit(500)  # Пополнено на 500
#
# # Снятие средств
# account.withdraw(300)  # Снято 300
#
# # Получение текущего баланса
# print(account.get_balance())  # 1200
#
# # **Объяснение:**
# #
# # * Приватный метод `__update_balance` обновляет баланс, но не доступен для прямого использования извне.
# # * Метод `deposit` и `withdraw` предоставляют интерфейс для работы с балансом, а детали реализации скрыты.
# # * Использование инкапсуляции позволяет избежать ошибок, связанных с прямым изменением баланса.
#
# ### Пример 3: Инкапсуляция с абстракцией
#
# # Теперь создадим класс `Employee`, который инкапсулирует имя, возраст и зарплату, но скрывает детали, как рассчитывается зарплата.
#
#
# class Employee:
#     def __init__(self, name, age, salary):
#         self.name = name
#         self.age = age
#         self.__salary = salary  # Приватный атрибут
#
#     # Геттер для зарплаты
#     def get_salary(self):
#         return self.__salary
#
#     # Сеттер для установки зарплаты
#     def set_salary(self, salary):
#         if salary < 0:
#             print("Зарплата не может быть отрицательной.")
#         else:
#             self.__salary = salary
#
#     # Метод для увеличения зарплаты
#     def increase_salary(self, percentage):
#         if percentage > 0:
#             self.__salary += self.__salary * (percentage / 100)
#             print(f"Зарплата увеличена на {percentage}%")
#         else:
#             print("Процент повышения должен быть положительным.")
#
# # Создание объекта
# employee = Employee("Eve", 30, 5000)
#
# # Увеличение зарплаты
# employee.increase_salary(10)  # Зарплата увеличена на 10%
#
# # Получение зарплаты
# print(employee.get_salary())  # 5500
#
# # Установка новой зарплаты
# employee.set_salary(6000)
# print(employee.get_salary())  # 6000
#
#
# # **Объяснение:**
# #
# # * Метод `increase_salary` скрывает детали, как именно вычисляется увеличение зарплаты, предоставляя абстракцию для пользователей.
# # * Приватный атрибут `__salary` не может быть изменен напрямую извне, и любые изменения должны проходить через предоставленные методы.
#
# ### Резюме:
#
# # Инкапсуляция — это принцип ООП, который скрывает внутреннюю реализацию класса и предоставляет интерфейс для работы с объектами. Это помогает обеспечить контроль над доступом к данным и улучшить безопасность программы.
# #
# # * Приватные атрибуты и методы скрыты от пользователя и доступны только через публичные интерфейсы (геттеры и сеттеры).
# # * С помощью инкапсуляции можно скрыть сложную логику и оставить только необходимые для пользователя функции.
#
#
#
# # Урок 28: Инкапсуляция - Задачи
#
# # 1. Создайте класс Person, который имеет публичный атрибут name и приватный атрибут age.
# # Реализуйте геттер и сеттер для age, чтобы нельзя было установить возраст менее 0.
# # Используйте геттер для получения возраста и сеттер для изменения значения.
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = 0
        self.age = age

    @property
    def age(self):
        """Геттер для возраста"""
        return self._age

    @age.setter
    def age(self, value):
        """Сеттер с проверкой на отрицательное значение"""
        if value < 0:
            print("Возраст не может быть меньше 0.")
        else:
            self._age = value

p = Person("Геннадий", 30)
print(p.name)
print(p.age)

p.age = -5
print(p.age)

p.age = 40
print(p.age)
#
# # 2. Создайте класс BankAccount, который имеет приватный атрибут balance.
# # Реализуйте геттер и сеттер для баланса, чтобы нельзя было вывести больше денег, чем на счете.
# class BankAccount:
#     def __init__(self, initial_balance=0):
#         self._balance = initial_balance  # Приватный атрибут
#
#     @property
#     def balance(self):
#         """Геттер для баланса"""
#         return self._balance
#
#     @balance.setter
#     def balance(self, value):
#         """Сеттер с проверкой: нельзя установить баланс меньше текущего минус остаток"""
#         if value < 0:
#             raise ValueError("Баланс не может быть отрицательным.")
#         self._balance = value
#
#     def deposit(self, amount):
#         self._balance += amount
#
#     def withdraw(self, amount):
#         if amount > self._balance:
#             raise ValueError("Недостаточно средств.")
#         self._balance -= amount
# acc = BankAccount(100)
# acc.deposit(50)
# print(acc.balance)
# acc.withdraw(40)
# print(acc.balance)
# acc.withdraw(200)

# # 3. Создайте класс Book, который имеет публичный атрибут title и приватный атрибут author.
# # Реализуйте методы для изменения имени автора через сеттер.
class Book:
    def __init__(self, title, author):
        self.title = title
        self._author = author

    @property
    def author(self):
        """Геттер для автора"""
        return self._author

    @author.setter
    def author(self, new_author):
        """Сеттер для изменения имени автора"""
        if new_author:
            self._author = new_author
        else:
            raise ValueError("Имя автора не может быть пустым.")
b = Book("Война и мир", "Лев Толстой")
print(b.title)
print(b.author)

b.author = "Толстой Л.Н."
print(b.author)



# # 4. Создайте класс Rectangle с приватными атрибутами length и width.
# # Добавьте геттеры и сеттеры для изменения этих значений.
# # Реализуйте метод для вычисления площади прямоугольника.
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    @property
    def length(self):
        return self._length

    @length.setter
    def length(self, value):
        if value > 0:
            self._length = value
        else:
            raise ValueError("Длина должна быть положительной.")

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        if value > 0:
            self._width = value
        else:
            raise ValueError("Ширина должна быть положительной.")

    def area(self):
        """Вычислить площадь"""
        return self._length * self._width

    def perimeter(self):
        """Вычислить периметр"""
        return 2 * (self._length + self._width)

    def __str__(self):
        return f"Прямоугольник: длина = {self._length}, ширина = {self._width}"
rect = Rectangle(4, 6)
print(rect)
print("Площадь:", rect.area())
print("Периметр:", rect.perimeter())

rect.length = 10
rect.width = 3
print("Новая площадь:", rect.area())

# # 5. Создайте класс Product, который будет иметь приватные атрибуты name, price и quantity.
# # Напишите методы для изменения этих атрибутов с проверками на правильность данных (например, цена не может быть отрицательной).
class Product:
    def __init__(self,name,price,quantity ):
        self._name = name
        self._price = price
        self._quantity = quantity

# # 6. Создайте класс Circle, который имеет приватный атрибут radius.
# # Напишите методы для получения и изменения радиуса круга и для вычисления его площади.
#
# # 7. Создайте класс Student, который имеет публичный атрибут name и приватный атрибут marks.
# # Реализуйте методы для добавления и получения оценок, с возможностью вывода среднего балла.
#
# # 8. Добавьте в класс Employee метод display_salary(), который будет показывать зарплату сотрудника,
# # если она больше 1000, иначе вывести сообщение "Зарплата недостаточна".
#
# # 9. Создайте класс Vehicle, который имеет приватные атрибуты make, model, и year.
# # Напишите методы для получения и изменения этих атрибутов.
# # Реализуйте метод для вычисления возраста автомобиля.
#
# # 10. Создайте класс Person, который имеет приватные атрибуты name и phone_number.
# # Реализуйте метод для изменения номера телефона с проверкой на его корректность.
#
# # 11. Создайте класс Movie, который имеет приватные атрибуты title, director, и release_year.
# # Реализуйте метод для вывода информации о фильме.
#
# # 12. Создайте класс Employee, который имеет публичный атрибут name и приватный атрибут salary.
# # Напишите геттер и сеттер для зарплаты, с проверкой, что зарплата не может быть меньше 0.
#
# # 13. Создайте класс Ticket, который имеет приватные атрибуты price, seat_number.
# # Реализуйте методы для изменения цены билета и номера места с проверкой на корректность данных.
#
# # 14. Создайте класс LibraryBook, который имеет публичные атрибуты title и приватные атрибуты author и publication_year.
# # Напишите методы для получения информации о книге.
#
# # 15. Создайте класс Account, который имеет приватные атрибуты account_number и balance.
# # Реализуйте методы для пополнения счета и вывода средств с проверкой на достаточность средств.
